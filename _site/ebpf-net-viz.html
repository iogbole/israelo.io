<!DOCTYPE html>
<html lang="en">




<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Getting Started with eBPF: Monitoring TCP Retransmissions Using eBPF, Go and Prometheus</title>
  <meta name='description'
    content='This is a beginner's guide to eBPF. Learn how to use eBPF, Go, and Prometheus to monitor network events unobtrusively. You'll learn how to use Linux tracepoi...'>

  <link rel="canonical" href="http://localhost:4000/ebpf-net-viz">
  <link rel="alternate" type="application/rss+xml" title="ISRAELO.IO" href="/%20/feed.xml">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Getting Started with eBPF: Monitoring TCP Retransmissions Using eBPF, Go and Prometheus – ISRAELO.IO">
  <meta name="twitter:description" content="This is a beginner&apos;s guide to eBPF. Learn how to use eBPF, Go, and Prometheus to monitor network events unobtrusively. You&apos;ll learn how to use Linux tracepoints to monitor TCP transmissions and use Prometheus to store and visualize the data you collect.">
  <meta name="twitter:image:src" content="https://user-images.githubusercontent.com/2548160/274512682-f06a933c-16e3-4288-a1fa-80237cc4b16d.png">

  <!-- Facebook OpenGraph -->
  <meta property="og:title" content="Getting Started with eBPF: Monitoring TCP Retransmissions Using eBPF, Go and Prometheus – ISRAELO.IO">
  <meta property="og:description" content="This is a beginner&apos;s guide to eBPF. Learn how to use eBPF, Go, and Prometheus to monitor network events unobtrusively. You&apos;ll learn how to use Linux tracepoints to monitor TCP transmissions and use Prometheus to store and visualize the data you collect.">
  <meta property="og:image" content="https://user-images.githubusercontent.com/2548160/274512682-f06a933c-16e3-4288-a1fa-80237cc4b16d.png">

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.gstatic.com">

  <link rel="preload" href="https://fonts.googleapis.com/css2?family=Jost:wght@400;500;700;900&display=swap" as="style">

  <link href="https://fonts.googleapis.com/css2?family=Jost:wght@400;500;700;900&display=swap" rel="stylesheet">


  <!-- Ionicons -->
  <link rel="preload" href="https://unpkg.com/ionicons@4.2.2/dist/css/ionicons.min.css" as="style">

  <link href="https://unpkg.com/ionicons@4.2.2/dist/css/ionicons.min.css" rel="stylesheet">


  <script>
    
    if (localStorage.getItem("theme") === "dark") {
      document.documentElement.setAttribute("dark", "");
      document.documentElement.classList.add('dark-mode');
    }
    
  </script>

  <style>
    {
      % capture include_to_scssify %
    }

      {
      % include main.scss %
    }

      {
      % endcapture %
    }

      {
        {
        include_to_scssify | scssify
      }
    }
  </style>
</head>

<body>

  
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-186535929-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'UA-186535929-1');
</script>
  

  <!-- begin header -->
<header class="header" id="top">
  <div class="container">
    <div class="row">
      <div class="header__inner col col-12">

        <div class="logo">
          <a class="logo__link" href="/">
          
            ISRAELO.IO
          
          </a>
        </div>

        <nav class="main-nav">
          <div class="main-nav__box">
            <div class="nav__icon-close">
              <i class="ion ion-md-close"></i>
            </div>
            <div class="nav__title">Menu</div>
            <ul class="nav__list list-reset">
              <li class="nav__item">
                <a href="/" class="nav__link">Home</a>
              </li>
              
                
              
                
                  
                  <li class="nav__item">
                    <a href="/about/" class="nav__link">About</a>
                  </li>
                  
                
              
                
                  
                  <li class="nav__item">
                    <a href="/contact/" class="nav__link">Contact</a>
                  </li>
                  
                
              
                
                  
                  <li class="nav__item">
                    <a href="/elements/" class="nav__link">Elements</a>
                  </li>
                  
                
              
                
                  
                
              
                
                  
                
              
                
                  
                
              
                
              
                
                  
                
              
                
                  
                
              
                
                  
                
              
              
              <li class="nav__item nav__item-icon">
                <div class="toggle-theme">
                  <div class="toggle-moon" title="Enable dark mode"><i class="ion ion-ios-moon"></i></div>
                  <div class="toggle-sun" title="Enable light mode"><i class="ion ion-ios-sunny"></i></div>
                </div>
              </li>
              
            </ul>
          </div>
        </nav>

        <div class="nav-button">
          <i class="nav__icon icon__menu ion ion-md-menu"></i>
          <i class="nav__icon icon__search ion ion-md-search"></i>
        </div>

      </div>
    </div>
  </div>
</header>
<!-- end header -->

<!-- begin search -->
<div class="search">
  <div class="container">
    <div class="row">
      <div class="col col-12">
        <div class="search__box">
          <div class="search__group">
            <div class="search__close">
              <i class="ion ion-md-close"></i>
            </div>
            <label for="js-search-input" class="screen-reader-text">Search for Blog</label>
            <input type="text" id="js-search-input" class="search__text" autocomplete="off" placeholder="Type to search...">
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="container">
    <div class="row search-results-list" id="js-results-container"></div>
  </div>

</div>
<!-- end search -->

  <!-- begin content -->
  <main class="content" aria-label="Content">
    <div class="post-head">
  <div class="container">
    <div class="row">
      

      <div class="col col-12">
        <div class="post__info ">


          <h1 class="post__title">Getting Started with eBPF: Monitoring TCP Retransmissions Using eBPF, Go and Prometheus</h1>

          <div class="post__meta">
            <a href="/about/" class="post__author-image">
              <img class="lazy" data-src="/images/01-1.jpg" alt="Israel Ogbole">
            </a>

            <div class="post__meta-bottom">

              <a class="post__author" href="/about/">Israel Ogbole</a>
              <time class="post__date" datetime="2023-10-12T07:01:35+01:00">12 Oct 2023</time>
            </div>
          </div>



        </div>
      </div>


      

      
      <div class="col col-12">
        <div class="post-image">
          <img class="lazy" data-src="https://user-images.githubusercontent.com/2548160/274512682-f06a933c-16e3-4288-a1fa-80237cc4b16d.png" alt="Getting Started with eBPF: Monitoring TCP Retransmissions Using eBPF, Go and Prometheus">
        </div>
      </div>
      

      

      
      <div class="post__tags" style="margin: 0 auto;">
        <span>Tags:</span>
        
        <a href="/tags#ebpf" class="post__tag">ebpf</a>
        
        <a href="/tags#observability" class="post__tag">observability</a>
        

      </div>
      

    </div>
  </div>
</div>

<!-- begin post -->
<div class="container animate">

  <article class="post">

    <div class="post__content">
      <p>As a Product Manager in tech, I strongly believe it is essential to understand the technology that underpins the products I manage. This knowledge not only allows me to keep pace with the evolving industry trends but also enriches my interactions with both customers and my engineering counterparts.</p>

<p>Recently, I’ve been working on a product that uses Extended Berkeley Packet Filter (eBPF). eBPF is a revolutionary technology that allows users to extend the functionality of the Linux kernel without having to modify the kernel code itself. Intrigued to learn more, I got a copy of Liz Rice’s book, <a href="https://isovalent.com/books/learning-ebpf/">“Learning eBPF”</a>. The book is so enlightening that I couldn’t resist rolling up my sleeves to get hands-on with this revolutionary technology, albeit a little.</p>

<p>Further, a specific focus for me has been the use of eBPF for monitoring TCP retransmissions, which can occur when a TCP segment goes unacknowledged by its receiver within a designated time frame. My interest in TCP retransmissions stems from a challenging experience troubleshooting intermittent connectivity issues with an APM agent in a customer’s production environment, in a previous role. Had eBPF been in my toolkit back then, that painful issue would have been far easier to diagnose and resolve.</p>

<p>This blog aims to chronicle my exploration of eBPF and Go and is targeted at anyone interested in learning eBPF. We will delve into the fundamentals of monitoring network events using eBPF, Go, and Prometheus.</p>

<blockquote>
  <p>The source code is available at <a href="https://github.com/iogbole/ebpf-network-viz">https://github.com/iogbole/ebpf-network-viz</a></p>
</blockquote>

<p>Let’s begin by defining the problem.</p>

<h2 id="the-ghost-in-the-network-tcp-retransmissions">The Ghost in the Network: TCP Retransmissions</h2>

<p>TCP retransmissions aren’t inherently bad; they’re a fundamental part of how TCP/IP networks function. However, when they occur frequently, they can signify network issues that lead to poor application performance. A high number of retransmissions can cause:</p>

<ul>
  <li><strong>Increased Latency</strong>: Packets have to be sent again, which takes extra time.</li>
  <li><strong>Higher CPU Usage</strong>: Both sending and receiving systems have to do additional work to handle the retransmissions.</li>
  <li><strong>Bandwidth Inefficiency</strong>: Retransmissions consume bandwidth that could be better used by new data.</li>
  <li><strong>User Experience Degradation</strong>: All the above contribute to a laggy or suboptimal user experience.</li>
</ul>

<p align="center">
<img width="600" alt="tcp retransmission" src="https://github-production-user-asset-6210df.s3.amazonaws.com/2548160/273732239-ec8dd025-ea85-4e7f-9ef3-0063ff75f1e0.png" />
</p>

<p>Imagine working on a high-speed, low-latency product and encountering intermittent slowdowns in data transmission. This situation can be tricky to diagnose and could bring your product to its knees. When I faced this issue, I took it upon myself to delve deep and understand what was happening under the hood. <strong>Wireshark led me to the root cause: excessive TCP retransmissions</strong> due to a faulty firewall policy.</p>

<p>One can easily trigger TCP retransmission, by executing:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>tc qdisc add dev eth0 root netem loss 10% delay 100ms
</code></pre></div></div>
<p>and it will surely mess up your network performance and introduce high CPU usage. I was once crazy enough to use 50% on an EC2 instance and it booted me out of SSH connection until I restarted the node via the console.  <strong>Do not try this out at home ;)</strong></p>

<p>The goal of this experiment is simple: to collect all TCP retransmissions from the kernel and push the metrics to Prometheus, so that you can slice and dice the data as well as generate alerts if the retransmission rate exceeds a threshold.</p>

<p><img width="1510" alt="prom" src="https://user-images.githubusercontent.com/2548160/274725653-9b2ac550-01cc-4015-befb-9539a9b38d03.gif" /></p>

<h2 id="why-ebpf">Why eBPF?</h2>
<p>eBPF is a revolutionary technology that allows users to extend the functionality of the Linux kernel without having to modify the kernel code itself. It is essentially a lightweight, sandboxed virtual machine that resides within the kernel, offering secure and verified access to kernel memory.</p>

<p>Moreso, eBPF code is typically written in a restricted subset of the <code class="language-plaintext highlighter-rouge">C</code> language and compiled into eBPF bytecode using a compiler like Clang/LLVM. This bytecode undergoes rigorous verification to ensure that it cannot intentionally or inadvertently jeopardize the integrity of the kernel. Additionally, eBPF programs are guaranteed to execute within a finite number of instructions, making them suitable for performance-sensitive use cases like observability and network security.</p>

<p>Here are some of the key benefits of using eBPF:</p>

<ul>
  <li><strong>Safety and security</strong>: eBPF programs are sandboxed and verified, which means that they cannot harm the kernel or the system as a whole.</li>
  <li><strong>Performance</strong>: eBPF programs are extremely efficient and can be used to implement complex functionality without impacting system performance.</li>
  <li><strong>Flexibility</strong>: eBPF can be used to implement a wide range of functionality, including network monitoring, asset discovery, security, profiling, performance tracing, and more.</li>
</ul>

<p>Functionally, eBPF allows you to run this restricted C code in response to various events, such as timers, network events, or function calls within both the kernel and user space. These event hooks are often referred to as ‘probes’—<code class="language-plaintext highlighter-rouge">kprobes</code> for kernel function calls, <code class="language-plaintext highlighter-rouge">uprobes</code> for user-space function calls, and <code class="language-plaintext highlighter-rouge">tracepoints</code> for pre-defined hooks in the Linux kernel.</p>

<p>In the context of this blog post, we’ll be focusing on <code class="language-plaintext highlighter-rouge">tracepoints</code>, specifically leveraging the <code><em>tcp_retransmit_skb</em></code>  tracepoint for monitoring TCP retransmissions.</p>

<p>If you are completely new to eBPF, I recommend checking out the resources in the reference section below, starting with <a href="https://ebpf.io/what-is-ebpf/">What is eBPF</a>?</p>

<h2 id="preparation-and-environment-setup">Preparation and Environment Setup</h2>
<p>Before we begin, it’s important to have your development environment properly configured. While this blog isn’t an exhaustive tutorial, I’ll outline the key prerequisites briefly.</p>

<h3 id="using-lima-on-macos"><strong>Using Lima on MacOS</strong></h3>
<p>If you’re a MacOS user like me, Lima is an excellent and easy way to emulate a Linux VM. To kick things off with Lima, follow these steps:</p>

<ol>
  <li>
    <p><a href="https://lima-vm.io/docs/installation/">Install Lima</a> and launch it with the <a href="https://github.com/iogbole/ebpf-network-viz/blob/main/ebpf-vm.yaml">ebpf-vm.yaml</a> file:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> limactl start ebpf-vm.yaml
 limactl shell ebpf-vm
</code></pre></div>    </div>
  </li>
  <li>
    <p>If you use Visual Studio Code, you can connect to the Lima VM via SSH:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> limactl show-ssh ebpf-vm
</code></pre></div>    </div>
    <p>Subsequently, use the SSH command to link up with the remote server from the VS Code on your host machine. Lima handles file sharing and 
 port forwaring automatically.</p>
  </li>
  <li>
    <p>After establishing the connection, clone the required repository:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> git clone https://github.com/iogbole/ebpf-network-viz.git
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="manual-setup-on-linux"><strong>Manual Setup on Linux</strong></h3>

<p>If you’re opting for a manual setup on Linux, refer to the script section in the <a href="https://github.com/iogbole/ebpf-network-viz/blob/main/ebpf-vm.yaml#L18">ebpf-vm.yaml</a> file.</p>

<p>With your environment now primed, you’re all set to delve into the fascinating world of eBPF!</p>

<h2 id="the-solution">The Solution</h2>

<p>The diagram below depicts the solution.</p>

<p align="center">
<img width="1510" alt="the solution" src="https://user-images.githubusercontent.com/2548160/274510771-99bb4583-c7be-4e3e-83fc-283ea99d0195.png" />
</p>

<h3 id="overview-of-the-components">Overview of the Components</h3>

<p>This is how the code works at a very high level:</p>

<ol>
  <li>
    <p><strong>Bytecode Loaded by Go</strong>: The eBPF bytecode is loaded into the kernel using a Go program, which makes use of the <code class="language-plaintext highlighter-rouge">github.com/cilium/ebpf</code> package.</p>
  </li>
  <li>
    <p><strong>eBPF Code Hooks to Tracepoints</strong>: The eBPF program uses the <code class="language-plaintext highlighter-rouge">tracepoint/tcp/tcp_retransmit_skb</code> to monitor TCP retransmissions. This allows the code to trigger whenever a TCP packet is retransmitted.</p>
  </li>
  <li>
    <p><strong>Collect Retransmission Events</strong>: The data relating to the retransmitted packets—such as IP addresses, ports, and the protocol family are collected in a structured manner.</p>
  </li>
  <li>
    <p><strong>Use of eBPF Maps</strong>: eBPF maps are used to communicate between the eBPF code running in the kernel and the Go application running in user space.</p>
  </li>
  <li>
    <p><strong>Perf Buffer</strong>: A perf event buffer is used to read the events generated by the eBPF code.</p>
  </li>
  <li>
    <p><strong>Exposed to HTTP</strong>: The Go application exposes the metrics over HTTP on port 2112.</p>
  </li>
  <li>
    <p><strong>Prometheus Scrapes Metrics</strong>: Finally, Prometheus is configured to scrape these exposed metrics for monitoring or alerting purposes.</p>
  </li>
</ol>

<h3 id="anatomy-of-the-ebpf-c-code">Anatomy of the eBPF C Code</h3>
<p>source: <a href="https://github.com/iogbole/ebpf-network-viz/blob/main/src/ebpf/retrans.c">retrans.c</a></p>

<h4 id="bpf-co-re">BPF CO-RE</h4>

<p>The headers are essential for the program to function correctly. Notably, <a href="https://github.com/iogbole/ebpf-network-viz/blob/main/src/ebpf/vmlinux.h"><code class="language-plaintext highlighter-rouge">vmlinux.h</code></a> is a header generated by BPF CO-RE. BPF CO-RE (Compile Once, Run Everywhere) enhances the portability of eBPF programs across different kernel versions. It resolves as much as possible at compile time, using placeholders for kernel-specific information that can only be determined at runtime. When the program is loaded into the kernel, these placeholders are populated with actual values. This flexibility eliminates the need for recompilation when deploying on different kernel versions. Through BPF CO-RE, the <code class="language-plaintext highlighter-rouge">vmlinux.h</code> header is generated to represent kernel structures, making it easier to write eBPF programs that are not tightly bound to specific kernels.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"vmlinux.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;bpf/bpf_helpers.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;bpf/bpf_endian.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;bpf/bpf_tracing.h&gt;</span><span class="cp">
</span></code></pre></div></div>

<p>To generate the <code class="language-plaintext highlighter-rouge">vmlinux.h</code> file, execute:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bpftool btf dump file /sys/kernel/btf/vmlinux format c <span class="o">&gt;</span> vmlinux.h
</code></pre></div></div>

<h4 id="data-structures">Data Structures</h4>

<p>The <code class="language-plaintext highlighter-rouge">event</code> and <code class="language-plaintext highlighter-rouge">tcp_retransmit_skb_ctx</code> structures are defined to hold the information related to TCP retransmissions. The structures collect various fields such as timestamps, process IDs, source and destination ports, and more.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">event</span> <span class="p">{</span>
    <span class="n">__u64</span> <span class="n">timestamp</span><span class="p">;</span>
    <span class="n">__u32</span> <span class="n">pid</span><span class="p">;</span>
    <span class="n">__u16</span> <span class="n">sport</span><span class="p">,</span> <span class="n">dport</span><span class="p">;</span>
    <span class="n">__u8</span> <span class="n">saddr</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">daddr</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="n">__u8</span> <span class="n">saddr_v6</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="n">daddr_v6</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
    <span class="n">__u16</span> <span class="n">family</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">state</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Struct to receive context from tracepoint</span>
<span class="k">struct</span> <span class="n">tcp_retransmit_skb_ctx</span> <span class="p">{</span>
    <span class="n">__u64</span> <span class="n">_pad0</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">skbaddr</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">skaddr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">state</span><span class="p">;</span>
    <span class="n">__u16</span> <span class="n">sport</span><span class="p">;</span>
    <span class="n">__u16</span> <span class="n">dport</span><span class="p">;</span>
    <span class="n">__u16</span> <span class="n">family</span><span class="p">;</span>
    <span class="n">__u8</span> <span class="n">saddr</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="n">__u8</span> <span class="n">daddr</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="n">__u8</span> <span class="n">saddr_v6</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
    <span class="n">__u8</span> <span class="n">daddr_v6</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="p">};</span>

</code></pre></div></div>

<h5 id="finding-data-structures-for-other-tracepoints"><strong>Finding Data Structures for Other Tracepoints</strong></h5>

<p>Understanding the data structures associated with tracepoints is a key aspect when you’re diving into eBPF programs for monitoring or debugging. While I focused on the <code class="language-plaintext highlighter-rouge">tcp_retransmit_skb</code> tracepoint in this blog, you may wish to explore other tracepoints. Here’s how you can discover the necessary data structures for those:</p>

<ol>
  <li>
    <p><strong>Locate Tracepoint Definitions</strong>: Typically, tracepoints are defined within the Linux Kernel source code. The definitions can usually be found under <code class="language-plaintext highlighter-rouge">/sys/kernel/debug/tracing/events/</code> directory on a Linux system with the tracing subsystem enabled. Navigate through the folders to find the tracepoint of interest.</p>
  </li>
  <li>
    <p><strong>Reading Format Files</strong>: Within each tracepoint directory, you’ll find a <code class="language-plaintext highlighter-rouge">format</code> file that describes the event structure. This will provide you with the types and names of the fields that are available for that particular tracepoint.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">cat</span> /sys/kernel/debug/tracing/events/tcp/tcp_retransmit_skb/format
</code></pre></div>    </div>

    <p>This will display the format for the <code class="language-plaintext highlighter-rouge">tcp_retransmit_skb</code> tracepoint as an example.</p>
  </li>
</ol>

<p>By familiarising yourself with the format files and possibly the kernel source code, you can create or adapt eBPF programs to tap into a wide range of system events, not just TCP retransmissions.</p>

<h4 id="bpf-maps">BPF Maps</h4>

<p>The BPF map <code class="language-plaintext highlighter-rouge">events</code> is defined as a perf event array. This map serves as a communication channel between user space (Go program) and kernel space (eBPF program).</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="p">{</span>
    <span class="n">__uint</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">BPF_MAP_TYPE_PERF_EVENT_ARRAY</span><span class="p">);</span>
    <span class="n">__uint</span><span class="p">(</span><span class="n">key_size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u32</span><span class="p">));</span>
    <span class="n">__uint</span><span class="p">(</span><span class="n">value_size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u32</span><span class="p">));</span>
<span class="p">}</span> <span class="n">events</span> <span class="nf">SEC</span><span class="p">(</span><span class="s">".maps"</span><span class="p">);</span>

</code></pre></div></div>

<h4 id="tracepoint-function">Tracepoint Function</h4>

<p>The function <code class="language-plaintext highlighter-rouge">tracepoint__tcp__tcp_retransmit_skb</code> is attached to the <code class="language-plaintext highlighter-rouge">tcp_retransmit_skb</code> tracepoint. Here, various fields are read and stored in an <code class="language-plaintext highlighter-rouge">event</code> structure.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">SEC</span><span class="p">(</span><span class="s">"tracepoint/tcp/tcp_retransmit_skb"</span><span class="p">)</span>
<span class="kt">int</span> <span class="nf">tracepoint__tcp__tcp_retransmit_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_retransmit_skb_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
 <span class="c1">// ... code logic</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="compiling-the-ebpf-code">Compiling the eBPF Code</h4>

<p>Compile the eBPF program using the script <a href="https://github.com/iogbole/ebpf-network-viz/blob/main/run_clang.sh"><code class="language-plaintext highlighter-rouge">run_clang.sh</code></a>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
clang <span class="nt">-O2</span> <span class="nt">-g</span> <span class="nt">-target</span> bpf <span class="nt">-c</span> ./ebpf/retrans.c <span class="nt">-o</span> ./ebpf/retrans.o <span class="nt">-I</span>/usr/include <span class="nt">-I</span>/usr/src/linux-headers-<span class="si">$(</span><span class="nb">uname</span> <span class="nt">-r</span><span class="si">)</span>/include  <span class="nt">-D</span> __BPF_TRACING__

</code></pre></div></div>

<h3 id="the-go-program">The Go Program</h3>

<p>source: <a href="https://github.com/iogbole/ebpf-network-viz/blob/main/src/main.go">main.go</a></p>

<h4 id="import-packages">Import Packages</h4>

<p>The code starts by importing necessary Go packages including eBPF and Prometheus libraries.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">import</span> <span class="p">(</span>
    <span class="s">"github.com/cilium/ebpf"</span>
    <span class="s">"github.com/prometheus/client_golang/prometheus"</span>
    <span class="c">// ... other imports</span>
<span class="p">)</span>

</code></pre></div></div>

<h4 id="loading-the-ebpf-program">Loading the eBPF Program</h4>

<p>Here, the eBPF bytecode is loaded from the <code class="language-plaintext highlighter-rouge">.o</code> object file. I opted to load the eBPF bytecode from a pre-compiled .o object file. This object file contains the bytecode of our eBPF program, which is what gets executed within the kernel. I chose this approach to maintain a clear separation of concerns: the compilation of the eBPF program is distinct from its execution. Other examples I have seen use gobpf libraries to load the C code at compile time - this approach might be easier from a CI/CD build process.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c">// Load eBPF program</span>
	<span class="n">spec</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">ebpf</span><span class="o">.</span><span class="n">LoadCollectionSpec</span><span class="p">(</span><span class="n">objFileName</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="n">coll</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">ebpf</span><span class="o">.</span><span class="n">NewCollectionWithOptions</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">ebpf</span><span class="o">.</span><span class="n">CollectionOptions</span><span class="p">{</span>
		<span class="n">Programs</span><span class="o">:</span> <span class="n">ebpf</span><span class="o">.</span><span class="n">ProgramOptions</span><span class="p">{</span>
			<span class="c">//Verbose to catch eBPF verifier issues</span>
			<span class="n">LogLevel</span><span class="o">:</span> <span class="m">1</span><span class="p">,</span>
			<span class="n">LogSize</span><span class="o">:</span>  <span class="m">65535</span><span class="p">,</span>
		<span class="p">},</span>
	<span class="p">})</span>
  <span class="o">....</span>
</code></pre></div></div>

<h4 id="attach-to-tracepoint">Attach to Tracepoint</h4>

<p>The program attaches to the <code class="language-plaintext highlighter-rouge">tcp_retransmit_skb</code> tracepoint using the <code class="language-plaintext highlighter-rouge">link.Tracepoint</code> function.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">tp</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">link</span><span class="o">.</span><span class="n">Tracepoint</span><span class="p">(</span><span class="s">"tcp"</span><span class="p">,</span> <span class="s">"tcp_retransmit_skb"</span><span class="p">,</span> <span class="n">prog</span><span class="p">,</span> <span class="no">nil</span><span class="p">)</span>

</code></pre></div></div>

<h4 id="perf-event-buffer">Perf Event Buffer</h4>

<p>A perf event buffer is set up to read events from the kernel space.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c">// Set up the perf buffer to receive events</span>
	<span class="n">events</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">perf</span><span class="o">.</span><span class="n">NewReader</span><span class="p">(</span><span class="n">coll</span><span class="o">.</span><span class="n">Maps</span><span class="p">[</span><span class="s">"events"</span><span class="p">],</span> <span class="n">os</span><span class="o">.</span><span class="n">Getpagesize</span><span class="p">())</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="n">events</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
</code></pre></div></div>

<p>The Perf Event Buffer plays an essential part in bridging the gap between user-space and kernel-space communication. This buffer is a data structure that’s set up to read events directly from the kernel. Essentially, it acts as a queuing mechanism, holding data that your eBPF program collects from various probes until your user-space application is ready to process it.</p>

<p>Here’s how it generally works:</p>

<ol>
  <li>
    <p>Your eBPF program attaches to specific kernel functions or tracepoints and collects data, such as packet information in the case of networking or syscall information for system-level observability.</p>
  </li>
  <li>
    <p>This data is then pushed to the Perf Event Buffer.</p>
  </li>
  <li>
    <p>Your user-space application, written in Go, in this case, then reads from this buffer to retrieve the data for further analysis or action.</p>
  </li>
</ol>

<p>The <strong><a href="https://www.kernel.org/doc/html/next/bpf/ringbuf.html">BPF ring buffer</a></strong> is a more modern alternative to Perf Event buffers, suitable for newer Kernel version</p>

<h3 id="exposing-metrics-to-prometheus">Exposing Metrics to Prometheus</h3>

<p>To expose the metrics gathered by your eBPF program for monitoring, I decided to use Prometheus in the setup. Here’s what I did:</p>

<h4 id="prometheus-metrics-definition">Prometheus Metrics Definition</h4>

<p>Firstly, define the events and metrics that Prometheus will scrape. In this instance:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">var</span> <span class="n">tcpRetransmissions</span> <span class="o">=</span> <span class="n">promauto</span><span class="o">.</span><span class="n">NewCounterVec</span><span class="p">(</span><span class="n">prometheus</span><span class="o">.</span><span class="n">CounterOpts</span><span class="p">{</span>
    <span class="n">Name</span><span class="o">:</span> <span class="s">"tcp_retransmissions_total"</span><span class="p">,</span>
    <span class="n">Help</span><span class="o">:</span> <span class="s">"Total number of TCP retransmissions"</span><span class="p">,</span>
<span class="p">},</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"ip_version"</span><span class="p">,</span> <span class="s">"src_ip"</span><span class="p">,</span> <span class="s">"src_port"</span><span class="p">,</span> <span class="s">"dst_ip"</span><span class="p">,</span> <span class="s">"dst_port"</span><span class="p">})</span>

</code></pre></div></div>

<h4 id="starting-the-http-server">Starting the HTTP Server</h4>

<p>After defining the metrics, the next step is to expose them through an HTTP endpoint. This is done by starting an HTTP server and mapping the <code class="language-plaintext highlighter-rouge">/metrics</code> path to a Prometheus handler:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c">// Start HTTP server for Prometheus scraping</span>
<span class="n">http</span><span class="o">.</span><span class="n">Handle</span><span class="p">(</span><span class="s">"/metrics"</span><span class="p">,</span> <span class="n">promhttp</span><span class="o">.</span><span class="n">Handler</span><span class="p">())</span>
<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">http</span><span class="o">.</span><span class="n">ListenAndServe</span><span class="p">(</span><span class="s">":2112"</span><span class="p">,</span> <span class="no">nil</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}()</span>

</code></pre></div></div>

<p>In this example, the HTTP server listens on port 2112, and Prometheus is configured to scrape metrics from this endpoint. When Prometheus accesses the <code class="language-plaintext highlighter-rouge">/metrics</code> path, it invokes the <code class="language-plaintext highlighter-rouge">promhttp.Handler()</code>, which in turn retrieves the metric data stored in <code class="language-plaintext highlighter-rouge">tcpRetransmissions</code>. This makes the data available for Prometheus to collect.</p>

<p>By combining these two components, you create a seamless pipeline that collects, exposes, and monitors TCP retransmission metrics in near real-time.</p>

<h4 id="the-event-loop-and-metrics-update">The Event Loop and Metrics Update</h4>

<p>The heart of the go code lies in the event loop, which continuously polls for new events from the perf event buffer. Each incoming event is processed and the relevant Prometheus metrics are updated accordingly.</p>

<p>The loop employs the <code class="language-plaintext highlighter-rouge">events.Read()</code> method on the perf buffer to listen for new incoming events:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="c">// Listen for events from the perf ring buffer</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Monitoring TCP retransmissions..."</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="n">sig</span><span class="o">:</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Received signal, stopping..."</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="k">default</span><span class="o">:</span>
			<span class="n">record</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">events</span><span class="o">.</span><span class="n">Read</span><span class="p">()</span>
			<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
				<span class="k">if</span> <span class="n">perf</span><span class="o">.</span><span class="n">IsUnknownEvent</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">continue</span>
				<span class="p">}</span>
				<span class="nb">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="p">}</span>

			<span class="n">event</span> <span class="o">:=</span> <span class="n">tcpRetransmitEvent</span><span class="p">{}</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">binary</span><span class="o">.</span><span class="n">Read</span><span class="p">(</span><span class="n">bytes</span><span class="o">.</span><span class="n">NewReader</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">RawSample</span><span class="p">),</span> <span class="n">binary</span><span class="o">.</span><span class="n">LittleEndian</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
				<span class="nb">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="p">}</span>
<span class="o">...</span>

</code></pre></div></div>

<p>Upon receiving an event, the loop processes it and updates the Prometheus <code class="language-plaintext highlighter-rouge">tcpRetransmissions</code> metric. The specifics of this processing depend on the structure and content of the events, which are designed to capture various data fields such as timestamps, process IDs, source and destination ports, and so forth.</p>

<p>To summarise, the event loop, in combination with the previously described Prometheus setup, allows the system to efficiently collect, process, and expose metrics for TCP retransmissions in a manner that is  consistent with other monitoring and observability tools.</p>

<p>Next, ensure the go code works:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nb">sudo </span>go run ./src/main.go

</code></pre></div></div>

<p>This is also a good time to confirm that the Go HTTP server is up and running:</p>
<p align="center">
<img width="1510" alt="go http server" src="https://user-images.githubusercontent.com/2548160/273732043-9f3ba1d3-1059-4bba-8ac5-715ecf73e817.png" />
</p>

<h3 id="setting-up-prometheus-in-the-lima-vm-using-nerdctl">Setting Up Prometheus in the Lima VM using nerdctl</h3>

<p>Since the development environment is within a Lima VM, it’s advantageous to leverage <code class="language-plaintext highlighter-rouge">nerdctl</code> for container management. <code class="language-plaintext highlighter-rouge">nerdctl</code> is a Docker-compatible CLI tool for containers, which is already bundled with Lima. Here’s how to set up Prometheus using a custom configuration and a shell script for automation.</p>

<h4 id="prometheus-configuration-prometheusyml">Prometheus Configuration: <code class="language-plaintext highlighter-rouge">prometheus.yml</code></h4>

<p>source: <a href="https://github.com/iogbole/ebpf-network-viz/blob/main/prom_config/prometheus.yml">prometheus.yml</a></p>

<p>The <code class="language-plaintext highlighter-rouge">prometheus.yml</code> configuration specifies how often Prometheus scrapes metrics and from where. In this case, it is configured to scrape the metrics exposed by the Go application running on port 2112.</p>

<p>Here’s the content of <code class="language-plaintext highlighter-rouge">prometheus.yml</code>:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">global</span><span class="pi">:</span>
  <span class="na">scrape_interval</span><span class="pi">:</span> <span class="s">15s</span>

<span class="na">scrape_configs</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">job_name</span><span class="pi">:</span> <span class="s1">'</span><span class="s">TCPRetrans'</span>
    <span class="na">static_configs</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">targets</span><span class="pi">:</span> <span class="pi">[</span><span class="s1">'</span><span class="s">127.0.0.1:2112'</span><span class="pi">]</span>
</code></pre></div></div>

<h4 id="shell-script-for-automated-setup">Shell Script for Automated Setup</h4>

<p>The shell script performs several tasks to ensure Prometheus runs correctly:</p>

<ol>
  <li>
    <p><strong>Getting the IP Address</strong>: The script first retrieves the IP address of <code class="language-plaintext highlighter-rouge">eth0</code> on the host machine.</p>
  </li>
  <li>
    <p><strong>Updating Configuration</strong>: It then replaces the IP address in the <code class="language-plaintext highlighter-rouge">prometheus.yml</code> configuration file to point to the correct address where the Go application is exposing metrics.</p>
  </li>
  <li>
    <p><strong>Running Prometheus</strong>: Finally, it runs the Prometheus container using nerdctl, mapping it to port 9090.</p>
  </li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c">#!/bin/bash</span>

<span class="nv">IP_ADDRESS</span><span class="o">=</span><span class="si">$(</span>ip <span class="nt">-4</span> addr show eth0 | <span class="nb">grep</span> <span class="nt">-oP</span> <span class="s1">'(?&amp;lt;=inet\s)\d+(\.\d+){3}'</span><span class="si">)</span>

<span class="c"># Replace the IP address in the prometheus.yml file.</span>
<span class="nv">CONFIG_FILE</span><span class="o">=</span><span class="s2">"prom_config/prometheus.yml"</span>
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s2">"s/[0-9]</span><span class="se">\+\.</span><span class="s2">[0-9]</span><span class="se">\+\.</span><span class="s2">[0-9]</span><span class="se">\+\.</span><span class="s2">[0-9]</span><span class="se">\+</span><span class="s2">:2112/</span><span class="k">${</span><span class="nv">IP_ADDRESS</span><span class="k">}</span><span class="s2">:2112/g"</span> <span class="s2">"</span><span class="nv">$CONFIG_FILE</span><span class="s2">"</span>
<span class="nb">echo</span> <span class="s2">"Updated prometheus.yml with IP address: </span><span class="nv">$IP_ADDRESS</span><span class="s2">"</span>
<span class="nb">sleep </span>3
nerdctl run <span class="nt">--rm</span> <span class="nt">-p</span> 9090:9090 <span class="nt">-v</span> <span class="s2">"</span><span class="nv">$PWD</span><span class="s2">/prom_config:/etc/prometheus"</span> prom/prometheus

</code></pre></div></div>

<p>This script automates the process, making it easier to deploy Prometheus within your Lima VM.</p>

<p>Since Lima also does automatic port forwarding, you should be able to access Prometheus on your host machine at <code class="language-plaintext highlighter-rouge">localhost:9090</code> and the metrics exposed by the Go application at <code class="language-plaintext highlighter-rouge">localhost:2112/metrics</code>.</p>

<p>Check and ensure that the job_name is registered.</p>

<p align="center">
<img width="1510" alt="prom_config" src="https://user-images.githubusercontent.com/2548160/273732084-60e7b5fa-d165-4740-ac64-10acc8636c62.png" />
</p>

<h2 id="create-tcp-chaos-testing-it-all-out">Create TCP Chaos: Testing It All Out</h2>

<p>To put the eBPF program and Prometheus monitoring into action, you need to introduce network issues in the VM. The <code class="language-plaintext highlighter-rouge">tc</code> (traffic control) command in Linux allows you to simulate network issues for testing purposes. The <code class="language-plaintext highlighter-rouge">create_tcp_chaos.sh</code> shell script below automates this process, first creating the chaos and then removing it after the test.</p>

<h3 id="the-create_tcp_chaossh-shell-script">The create_tcp_chaos.sh Shell Script</h3>

<p>source : <a href="https://github.com/iogbole/ebpf-network-viz/blob/main/create_tcp_chaos.sh">create_tcp_chaos.sh</a></p>

<p>Here’s the script that introduces packet loss and latency to <code class="language-plaintext highlighter-rouge">eth0</code> using <code class="language-plaintext highlighter-rouge">tc</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c">#!/bin/bash</span>

<span class="c"># Define websites to send requests to.</span>
<span class="nv">websites</span><span class="o">=(</span><span class="s2">"http://example.com"</span> <span class="s2">"https://www.google.com"</span> <span class="s2">"https://www.wikipedia.org"</span><span class="o">)</span>
<span class="c"># Set the number of iterations for the loop.</span>
<span class="nv">loop_count</span><span class="o">=</span>20
<span class="c"># Introduce network latency and packet loss using tc.</span>
<span class="nb">sudo </span>tc qdisc add dev eth0 root netem loss 5% delay 100ms

<span class="c"># Loop to send requests to the websites.</span>

<span class="k">for</span> <span class="o">((</span>i <span class="o">=</span> 1<span class="p">;</span> i &lt;<span class="o">=</span> loop_count<span class="p">;</span> i++<span class="o">))</span><span class="p">;</span> <span class="k">do
    for </span>site <span class="k">in</span> <span class="s2">"</span><span class="k">${</span><span class="nv">websites</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">do
        </span><span class="nb">echo</span> <span class="s2">"Sending request to </span><span class="nv">$site</span><span class="s2"> (iteration </span><span class="nv">$i</span><span class="s2">)"</span>
        curl <span class="nt">-sS</span> <span class="s2">"</span><span class="nv">$site</span><span class="s2">"</span> <span class="o">&gt;</span> /dev/null  <span class="c"># s for silent and S for showing errors if they occur.</span>
        <span class="nb">sleep </span>1  <span class="c"># Wait for a second.</span>
        wget <span class="nt">-O-</span> <span class="s2">"</span><span class="nv">$site</span><span class="s2">"</span> <span class="o">&gt;</span> /dev/null  <span class="c"># O- redirects output to stdout, as we don't want to save the file.</span>

    <span class="k">done
done</span>

<span class="c"># Remove the traffic control rule.</span>

<span class="nb">sudo </span>tc qdisc del dev eth0 root

</code></pre></div></div>

<p>Run the script, and you should be able to observe the effects on your Prometheus metrics. Remember to execute the script with appropriate permissions.</p>

<h2 id="grab-a-coffee-reap-the-rewards">Grab a coffee: Reap the Rewards</h2>

<p>Head over to your Prometheus interface and type tcp_retransmissions_total into the query bar. Switch to the graph view and marvel at the results of your hard work.</p>

<p>You’re now in a position to set up alerts for TCP retransmissions. A common benchmark to consider is that a retransmission rate of 2% or greater generally indicates network issues that warrant attention.</p>

<p>So grab a cup of coffee, sit back, and enjoy the fruit of your labour!</p>

<p align="center">
<img width="1510" src="https://user-images.githubusercontent.com/2548160/273732219-e4b7bcf0-5d4a-456a-8197-543ecbcea061.png" />
</p>

<h1 id="refs">Refs</h1>

<ul>
  <li><a href="https://www.man7.org/linux/man-pages/man2/bpf.2.html">Must read - Linux Man Page</a></li>
  <li><a href="https://github.com/iovisor/bcc/blob/master/tools/tcpretrans_example.txt">TCP retrans fields</a></li>
  <li><a href="https://facebookmicrosites.github.io/bpf/blog/2020/02/19/bpf-portability-and-co-re.html">BPF CORE</a></li>
  <li><a href="https://www.brendangregg.com/blog/2018-03-22/tcp-tracepoints.html">TCP tracepoints</a></li>
  <li><a href="https://ebpf.io/applications/">eBPF applications</a></li>
</ul>

    </div>

    <div class="post__share">
      <ul class="share__list list-reset">
        <li class="share__item">
          <a class="share__link share__twitter"
            href="https://twitter.com/intent/tweet?text=Getting%20Started%20with%20eBPF:%20Monitoring%20TCP%20Retransmissions%20Using%20eBPF,%20Go%20and%20Prometheus&url=http://localhost:4000/ebpf-net-viz"
            onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;"
            title="Share on Twitter" rel="nofollow"><i class="ion ion-logo-twitter"></i></a>
        </li>
        <li class="share__item">
          <a class="share__link share__facebook"
            href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/ebpf-net-viz"
            onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;"
            title="Share on Facebook" rel="nofollow"><i class="ion ion-logo-facebook"></i></a>
        </li>
        <li class="share__item">
          <a class="share__link share__pinterest"
            href="http://pinterest.com/pin/create/button/?url=http://localhost:4000/ebpf-net-viz&amp;media=http://localhost:4000https://user-images.githubusercontent.com/2548160/274512682-f06a933c-16e3-4288-a1fa-80237cc4b16d.png&amp;description=Getting%20Started%20with%20eBPF:%20Monitoring%20TCP%20Retransmissions%20Using%20eBPF,%20Go%20and%20Prometheus"
            onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=900,height=500,toolbar=1,resizable=0'); return false;"
            title="Share on Pinterest" rel="nofollow"><i class="ion ion-logo-pinterest"></i></a>
        </li>
        <li class="share__item">
          <a class="share__link share__linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&url=http://localhost:4000/ebpf-net-viz&title=Getting%20Started%20with%20eBPF:%20Monitoring%20TCP%20Retransmissions%20Using%20eBPF,%20Go%20and%20Prometheus&summary=This%20is%20a%20beginner's%20guide%20to%20eBPF.%20Learn%20how%20to%20use%20eBPF,%20Go,%20and%20Prometheus%20to%20monitor%20network%20events%20unobtrusively.%20You'll%20learn%20how%20to%20use%20Linux%20tracepoints%20to%20monitor%20TCP%20transmissions%20and%20use%20Prometheus%20to%20store%20and%20visualize%20the%20data%20you%20collect.&source=ISRAELO.IO"
            onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;"
            title="Share on LinkedIn" rel="nofollow"><i class="ion ion-logo-linkedin"></i></a>
        </li>
      </ul>
    </div>


  </article>
</div>
<!-- end post -->







<!-- begin related posts -->
<div class="container">
  <section class="related-posts  animate">
    <div class="row">
      <div class="col col-12">
        <div class="container__inner">
          <div class="section__info">
            <div class="section__head">
              <h2 class="section__title">You may also like</h2>
              <a class="section__link" href="/blog">
                
                
                  
                    <a href="/tags#ebpf" class="section__link related-tag">See all<span> ebpf</span></a>
                  
                
                  
                
              
              </a>
            </div>
          </div>
          <div class="row">

          
            
            
      
            
      
            
            
            
            
      
            
      
            
            
            
            
      
            
      
            
            
            
            
      
            
      
            
            
            
            
      
            
      
            
            
            
            
      
            
      
            
            
            
            
      
            
      
            
            
            
            
      
            
      
            
            
            
            
      
            
      
            
            
            
            
      
            
      
            
            
            
            
      
            
      
            
            
            
            
      
            
      
            
            
            
            
      
            
      
            
            
          </div>
        </div>
      </div>
    </div>
  </section>
</div>
<!-- end related posts -->


<div class="container">
  <div class="row">
    <div class="col col-12">
      <!-- begin comments -->
<div class="show-comments">
  <button class="button disqus-button" id="show-comments-button" onclick="disqus();return false;">Show Comments</button>
</div>

<div id="disqus_thread" class="post__comments">
  <div id="disqus_empty"></div>
</div>

<script>
  var disqus_loaded = false;
  var disqus_shortname = 'demo-menca';
  var disqus_container = document.getElementById("disqus_thread");
  function disqus() {
    if (!disqus_loaded) {
      disqus_loaded = true;
      var e = document.createElement("script");
      e.type = "text/javascript";
      e.async = true;
      e.src = "//" + disqus_shortname + ".disqus.com/embed.js";
      (document.getElementsByTagName("head")[0] ||
        document.getElementsByTagName("body")[0])
        .appendChild(e);
      // Hide the button after opening
      document.getElementById("show-comments-button").style.display = "none";
      // Show disqus comments
      disqus_container.classList.add("is-open");
    }
  }
</script>

<noscript>Please enable JavaScript to view the
  <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>
<!-- end comments -->
    </div>
  </div>
</div>

  </main>
  <!-- end content -->

  <!-- begin footer -->
<footer class="footer">

  <div class="footer__inner">
    <div class="container">
      <div class="row">

        <div class="col col-5 col-d-12">
          <div class="footer__author">
            <div class="footer__author-avatar">
              <img class="lazy" data-src="/images/01-1.jpg" alt="Israel Ogbole">
            </div>
            <h3 class="footer__author-name">Israel Ogbole</h3>
            <p class="footer__author-bio">GirlDad, Engineering Product Manager, MSc, MBA, ex-Solutions Architect, ex-Software Engineer, and now an occasional blogger</p>
            
            <div class="social">
              <ul class="social__list list-reset">
                
                <li class="social__item">
                  <a class="social__link" href="https://twitter.com/israel_ogbole" target="_blank" rel="noopener"
                    aria-label=" link"><i class="ion ion-logo-twitter"></i></a>
                </li>
                
                <li class="social__item">
                  <a class="social__link" href="https://www.linkedin.com/in/israelo" target="_blank" rel="noopener"
                    aria-label=" link"><i class="ion ion-logo-linkedin"></i></a>
                </li>
                
                <li class="social__item">
                  <a class="social__link" href="https://github.com/iogbole" target="_blank" rel="noopener"
                    aria-label=" link"><i class="ion ion-logo-github"></i></a>
                </li>
                
              </ul>
            </div>
            
          </div>
        </div>

        
        <div class="col col-6 push-1 col-d-12 push-d-0">
          <div class="footer__gallery">
            <h3 class="footer__gallery-title">Gallery</h3>
            
            <div class="gallery-footer">
              <div class="gallery" style="grid-template-columns: repeat(3, auto);">
                
                <div class="gallery__image">
                  <img src="/images/100.jpg" alt="Rest" loading="lazy">
                </div>
                
                <div class="gallery__image">
                  <img src="/images/101.jpg" alt="Lifestyle" loading="lazy">
                </div>
                
                <div class="gallery__image">
                  <img src="/images/102.jpg" alt="Hobby" loading="lazy">
                </div>
                
                <div class="gallery__image">
                  <img src="/images/103.jpg" alt="Notes" loading="lazy">
                </div>
                
                <div class="gallery__image">
                  <img src="/images/104.jpg" alt="Rest" loading="lazy">
                </div>
                
                <div class="gallery__image">
                  <img src="/images/105.jpg" alt="Hobby" loading="lazy">
                </div>
                
                <div class="gallery__image">
                  <img src="/images/106.jpg" alt="Fashion" loading="lazy">
                </div>
                
                <div class="gallery__image">
                  <img src="/images/107.jpg" alt="Notes" loading="lazy">
                </div>
                
                <div class="gallery__image">
                  <img src="/images/108.jpg" alt="Rest" loading="lazy">
                </div>
                
              </div>
            </div>
            
          </div>
        </div>
        

      </div>
    </div>
  </div>

  <div class="footer__info">
    <div class="container">
      <div class="row">
        <div class="col col-12">
          <div class="footer__info-box">
            <div class="copyright">2023 &copy; <a href="/">ISRAELO.IO</a>. Crafted & Designed by <a href="https://jekyllthemes.io/developers/artem-sheludko">Artem Sheludko</a>.</div>
            <div class="top" title="Top"><i class="ion ion-ios-arrow-up"></i></div>
          </div>
        </div>
      </div>
    </div>
  </div>

</footer>
<!-- end footer -->

  <script src="/js/scripts.js"></script>
  <script src="/js/common.js"></script>


</body>

</html>